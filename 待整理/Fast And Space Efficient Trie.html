<html>
<head>
  <title>Evernote Export</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/600986 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <meta name="application-data:2525275" content="10389191/s94/c2e79cb5-3a98-402e-989c-67549dac2751/www.evernote.com"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="2434"/>

<div>
<span style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><div align="left"><font color="#010101" face="Times New Roman" size="2"><span style="font-size:10pt">Hash Tries, </span></font><span style="color: rgb(1, 1, 1); font-family: 'Times New Roman'; font-size: 13px;">Bentley, McIlory, and Knuth [1986] and TST.</span></div><div align="left"><span style="color: rgb(1, 1, 1); font-family: 'Times New Roman'; font-size: 13px;"><br/></span></div><div align="left"><div align="left"><span style="color: rgb(1, 1, 1); font-family: 'Times New Roman'; font-size: 13px;"><span style="border-collapse: separate; color: rgb(0, 0, 0); font-family: Tahoma; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; orphans: 2; text-align: -webkit-auto; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-border-horizontal-spacing: 0px; -webkit-border-vertical-spacing: 0px; -webkit-text-decorations-in-effect: none; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; font-size: medium;"><span style="font-size: 12px;">普通的Trie结构的问题在于每个节点都需要分配字符集大小的table来存储下一个位置的指针</span></span></span></div><div align="left"><span style="font-size: 12px;">假设字符集大小是S，key的长度是P，key的个数是N，那么静态Trie需要消耗s^p的空间，动态Trie需要消耗s*p*N的空间</span></div><div align="left"><span style="font-size: 12px;"><br/></span></div></div><div align="left"><span style="color: rgb(1, 1, 1); font-family: 'Times New Roman'; font-size: 13px;">Trie Search伪代码</span></div><div align="left"><div align="left" style="font-size: 13px;"><span style="color: rgb(1, 1, 1); font-family: 'Times New Roman';"><font color="#010101" face="Times New Roman" size="1"><span style="font-size:9pt">int Find(char *Key)</span></font></span></div><div align="left" style="font-size: 13px;"><font color="#010101" face="Times New Roman" size="1"><span style="font-size:9pt">{</span></font></div><div align="left" style="font-size: 13px;"><font color="#010101" face="Times New Roman" size="1"><span style="font-size:9pt">     TNode *P,*C;</span></font></div><div align="left" style="font-size: 13px;"><font color="#010101" face="Times New Roman" size="1"><span style="font-size:9pt">     P=Root;</span></font></div><div align="left" style="font-size: 13px;"><font color="#010101" face="Times New Roman" size="1"><span style="font-size:9pt">     while(C=Next(P,*Key)){Key++;P=C;}</span></font></div><div align="left" style="font-size: 13px;"><font color="#010101" face="Times New Roman" size="1"><span style="font-size:9pt">     if(*Key==0)return P-&gt;Value;</span></font></div><div align="left" style="font-size: 13px;"><font color="#010101" face="Times New Roman" size="1"><span style="font-size:9pt">          return 0;</span></font></div><div align="left" style="font-size: 13px;"><font color="#010101" face="Times New Roman" size="1"><span style="font-size:9pt">}</span></font></div><font color="#010101" face="'Times New Roman'"><span style="font-size: 12px;"><br/></span></font><div align="left"><span style="color: rgb(1, 1, 1); font-family: 'Times New Roman';"><span style="font-size: 12px;">Trie的搜索可以抽象成上述伪代码，Trie的效率取决于Next函数的效率。</span></span></div><div align="left"><span style="font-size: 12px;">普通的Trie，Next函数是O(1)的。</span></div><div align="left"><span style="font-size: 12px;"><br/></span></div><div align="left"><span style="font-size: 12px;">优化空间的方法是用TST替换table，对于table不是非常饱满的集合，TST可以省去很多空间。</span></div><div align="left"><span style="font-size: 12px;">而TST的Next函数时间复杂度通常小于O(lgS)。</span></div><div align="left"><span style="font-size: 12px;"><br/></span></div><div align="left"><div align="left" style="font-size: 12px;"><font color="#010101" face="Times New Roman" size="1"><span style="font-size:9pt">// TST Next Method</span></font></div><div align="left" style="font-size: 12px;"><font color="#010101" face="Times New Roman" size="1"><span style="font-size:9pt">Class Node {</span></font></div><div align="left" style="font-size: 12px;"><font color="#010101" face="Times New Roman" size="1"><span style="font-size:9pt">     char Splitchar;</span></font></div><div align="left" style="font-size: 12px;"><font color="#010101" face="Times New Roman" size="1"><span style="font-size:9pt">     Node *equal,*kidl,*kidr;</span></font></div><div align="left" style="font-size: 12px;"><font color="#010101" face="Times New Roman" size="1"><span style="font-size:9pt">};</span></font></div><div align="left" style="font-size: 12px;"><font color="#010101" face="Times New Roman" size="1"><span style="font-size:9pt">inline Node *Next(Node *P,unsigned char c)</span></font></div><div align="left" style="font-size: 12px;"><font color="#010101" face="Times New Roman" size="1"><span style="font-size:9pt">{</span></font></div><div align="left" style="font-size: 12px;"><font color="#010101" face="Times New Roman" size="1"><span style="font-size:9pt">     do{</span></font></div><div align="left" style="font-size: 12px;"><font color="#010101" face="Times New Roman" size="1"><span style="font-size:9pt">          if(P-&gt;Splitchar==c)return P-&gt;equal;</span></font></div><div align="left" style="font-size: 12px;"><font color="#010101" face="Times New Roman" size="1"><span style="font-size:9pt">          if(P-&gt;Splitchar&gt;c)P=P-&gt;kidl;</span></font></div><div align="left" style="font-size: 12px;"><font color="#010101" face="Times New Roman" size="1"><span style="font-size:9pt">          else P=P-&gt;kidr;</span></font></div><div align="left" style="font-size: 12px;"><font color="#010101" face="Times New Roman" size="1"><span style="font-size:9pt">     }while(P);</span></font></div><div align="left" style="font-size: 12px;"><font color="#010101" face="Times New Roman" size="1"><span style="font-size:9pt">     return NULL;</span></font></div><div align="left" style="font-size: 12px;"><font color="#010101" face="Times New Roman" size="1"><span style="font-size:9pt">}</span></font></div><div align="left" style="font-size: 12px;"><font color="#010101" face="Times New Roman" size="1"><span style="font-size:9pt"><br/></span></font></div><div align="left"><div align="left" style="font-size: 9pt;"><font color="#010101" face="Times New Roman"><font color="#010101" face="Times New Roman" size="2"><span style="font-size:10pt">ARRAY COMPACTED TREE (ACT)</span></font></font></div><div align="left" style="font-size: 9pt;"><font color="#010101" face="Times New Roman"><font color="#010101" face="Times New Roman" size="2"><span style="font-size:10pt">ACT是一种紧凑的TRIE。普通的TRIE由于大量的NULL指针浪费了许多空间，ACT则将内容不冲突的几个节点的TABLE合并，减少空间代价，在查询上能达到理想的O(1)，但是插入十分复杂。ACT比较适用与静态字典。</span></font></font></div></div></div><div align="left"><span style="color: rgb(1, 1, 1); font-family: 'Times New Roman';"><span style="color: rgb(1, 1, 1); font-family: 'Times New Roman';">ACT在插入的过程中如果遇到位置被占，需要将自己的TABLE做迁移，找一能够容纳TABLE的位置。插入的时间复杂度难以估算，但是据说和二叉树插入相当。</span></span></div><div align="left"><span style="color: rgb(1, 1, 1); font-family: 'Times New Roman';"><br/></span></div><div align="left"><span style="color: rgb(1, 1, 1); font-family: 'Times New Roman';">ARRAY MAPPED TREE(AMT)</span></div><div align="left"><div align="left"><span style="color: rgb(1, 1, 1); font-family: 'Times New Roman';"><font color="#010101" face="Times New Roman" size="2"><span style="font-size:10pt">The core concept is to use one bit in a bit map for each node that represents a</span></font></span></div><div align="left"><font color="#010101" face="Times New Roman" size="2"><span style="font-size:10pt">valid branch in the trie. For an alphabet cardinality of 256 this will require 256 bits</span></font></div><div align="left"><font color="#010101" face="Times New Roman" size="2"><span style="font-size:10pt">The symbol is used to index to the associated bit in the bit map. This bit is set to</span></font></div><div align="left"><font color="#010101" face="Times New Roman" size="2"><span style="font-size:10pt">one if a sub-trie exists or zero if there is none. A pointer list is associated with this</span></font></div><div align="left"><font color="#010101" face="Times New Roman" size="2"><span style="font-size:10pt">bit map containing an entry for each one bit in the bit map. Finding the branch for</span></font></div><div align="left"><font color="#010101" face="Times New Roman" size="2"><span style="font-size:10pt">a symbol</span> <span style="font-size:10pt"><i>s</i></span><span style="font-size:10pt">, requires finding its corresponding bit in the bit map and then counting</span></font></div><div align="left"><font color="#010101" face="Times New Roman" size="2"><span style="font-size:10pt">the bits below it in the map to calculate an index into an ordered sub-trie pointer</span></font></div><div align="left"><font color="#010101" face="Times New Roman" size="2"><span style="font-size:10pt">table. The cost of null branches is thereby reduced to one bit. This method is not</span></font></div><div align="left"><font color="#010101" face="Times New Roman" size="2"><span style="font-size:10pt">new and was first described by Bird [1977],Bird and TU. [1979], who conceived a</span></font></div><div align="left"><font color="#010101" face="Times New Roman" size="2"><span style="font-size:10pt">hardware solution to this problem. An efficient software algorithm to count bits in</span></font></div><div align="left"><font color="#010101" face="Times New Roman" size="2"><span style="font-size:10pt">the bit map provides the critical component for an AMT.</span></font></div><div align="left"><font color="#010101" face="Times New Roman" size="2"><span style="font-size:10pt"><br/></span></font></div><div align="left">AMT的核心思想是使用BIT MAP中的一个BIT来标识一个TRIE的分支。对于256大小的字母集合就需要256位来存储。通过SYMBOL可以定位到BIT MAP中对应的BIT。 如果相应的SUB TRIE存在，那么相应的BIT就是1，否则就是0。有一个指针的链表存储着BIT MAP中每个是1的BIT对应的SUB TRIE指针。想要找到某个SYMBOL S的SUB TRIE，需要找到它在BIT MAP中对应的BIT，然后计数所有低于该BIT的位得到它在指针链表中的INDEX。</div><div align="left">于是空的分支只需要消耗一个BIT的空间。</div></div></div></span>
</div></body></html> 